# Template Method パターン

# 登場人物

## AbstractClass 抽象クラス
Abstractは、テンプレートメソッドを実装します。また、そのテンプレートメソッドで使っている抽象メソッドを宣言します。この抽象メソッドは、サブクラスであるConcreteClassによって実装されます。

## ConcreteClass 具象クラス
抽象くらすで定義されている抽象メソッドを具体的に実装します。ここで実装したメソッドは、抽象クラスのテンプレートメソッドが呼び出されます。

```uml

class AbstractClass {
  method1
  method2
  method3
  templateMethod
}

class ConcreteClass {
  method1
  method2
  method3
}

AbstractClass<|-ConcreateClass

```

# 関連しているパターン
- Factory Method パターン
- Strategy パターン


# 考えてみよう
## スーパークラスからサブクラスへの要請
クラス階層について学ぶ時、大抵はサブクラスの視点で考えます。つまり、次のような点に目を向けがちです。

- スーパークラスで定義されているメソッドがサブクラスで利用できる
- サブクラスに少しメソッドを書くだけで新しい機能が追加できる
- サブクラスでメソッドをオーバーライドすれば振る舞いを変更できる

ここで視点を変えて、スーパークラスの気持ちになってみる。スーパクラスで抽象メソッドが宣言されてるとする。この時、そのメソッドの実装は「サブクラスに任されている」わけ。言い換えれば、抽象メソッドを宣言することによって、次の主張をしていることになる。

- サブクラスがそのメソッドを実装することを期待する
- サブクラスに対して、そのメソッドの実装を要請する

サブクラスには、スーパークラスで宣言されている抽象メソッドを実装するという責任が生じていると言ってもいいでしょう。
これを、*subclass responsibility* (サブクラスの責任) という

# 抽象クラスの意義
抽象クラスはインスタンスを作ることができない。抽象クラスを初めて学ぶとき、「インスタンスを作れないクラスなど何の役にたつのだろう」という疑問を持つ人もいるだろう。しかし、TemplateMethodパターンを理解すれば、その疑問は少し解消するでしょう。抽象メソッドにはメソッドの本体が書かれていないので、具体的な処理内容はわかりません。しかし、メソッドの名前を決め、そのメソッドを使ったテンプレートメソッドによって処理を記述することはできるのです。実際の処理内容はサブクラスまで行かなければ決まりませんが、*抽象クラスの段階で処理の流れを形作る*のは大切なことです。


